# HOMSA (옴사)
## Hamiltonian Optimal Microservice Architecture

---

# 1. 개요

HOMSA는 복잡 시스템의 보편적 분해 패턴에 해밀토니안 형식론을 적용하여, 소프트웨어 시스템의 설계-구현-운영-전환 판단을 단일 수학 체계로 관통하는 아키텍처 프레임워크다.

### 핵심 명제

**"복잡 시스템의 보편적 분해 패턴 — 독립 요소, 상호작용, 외부 입력, 시간적 보정 — 에 대해, 설계-구현-운영-전환 판단의 전 과정에 걸쳐 단일 형식에서 도출되는 분석 도구의 범위를 기준으로, 해밀토니안 형식론이 현재 알려진 대안 중 최적이다."**

이 명제는 6라운드의 독립적 적대적 검증(Gemini 2라운드 + Claude 4라운드)을 거쳐 합의되었다.

### 인식론적 위치

- 출발점은 물리학이 아니라 **대수적 분해**다. 시스템을 대수적으로 분해했을 때 해밀토니안 형식이 나타난다.
- **형식은 공유하고 해석은 분리한다.** 물리학의 해밀토니안(보존량)과 최적 제어의 해밀토니안(최적화 대상)은 형식이 같으므로 도구가 호환된다.
- S는 물리량이 아니다. 시스템의 대수적 기술(description)이다.

---

# 2. 기본식

## 2.1 시스템 해밀토니안

시스템을 대수적으로 분해하면 다음 형식이 나타난다:

```
S = ΣΣLₙ + ΣΣaₘLₘ + ΣΣL'ₙ + ΣDₚ + ΣEq
```

이 형식은 다체계 해밀토니안과 구조적으로 대응된다:

```
H = Σ h₀(xᵢ) + Σ v(rᵢⱼ) + Σ uₑₓₜ(xᵢ) + H'
```

## 2.2 각 항의 정의

### ΣΣLₙ — 독립 로직 (one-body term)

- 이중 시그마: 바깥 = 서비스(Xₙ), 안쪽 = 연산 항목
- 각 Lₙ은 **독립 사건**이다. Lₙ 간 직접 연결은 없다 (무조건 독립)
- Lₙ은 **암묵적 공유 상태**(전역 current user/project/session 등)를 금지한다
- 공유 상태가 필요하면 Dₚ에 명시 저장하고, 흐름 제어는 So 상태 전이로 승격한다
- 교환법칙 성립 (아벨군)
- 연산 단위는 enum으로 정의, 조합은 W(워크플로우)가 담당
- 프론트엔드와 백엔드 모두에 존재한다 (섹션 3 참조)

### ΣΣaₘLₘ — 워크플로우 커플링 (two-body interaction term)

- W = ΣLₙ (워크플로우는 독립적 Lₙ들의 합)
- W 전개 형식 예시: `W_checkout = L_VALIDATE_CART + L_CALC_PRICE + L_CREATE_ORDER + L_PAY + L_NOTIFY`
- aₘ: 분기 가중치
  - 항상 실행 = 1
  - 분기 중 하나 = 0.5
  - 3갈래 중 2개 = 0.67
- aₘ은 W 전체가 아니라 **개별 Lₘ에 붙는 계수**다
- So(orchestrator) = ΣWₖ = ΣΣaₘLₘ
- So 최소 규칙: **W 실행 이력과 상태 전이만** 가진다. 비즈니스 로직은 Lₙ에 남겨둔다
- So 운영 규약: W 시작/종료 지점 관리, 단계 전이 기록, 실패 시 재시도/중단 정책만 담당
- So 안정성 규약: 단계 전이는 idempotent하게 설계한다 (같은 입력/같은 단계 재실행 시 결과 안정)
- So 비대화 = ε 폭발의 가장 흔한 원인
- 같은 Lₘ이 다른 W에서 다른 aₘ을 가질 수 있다
- 분기마다 별도 W 정의 (W 내부에 분기 없음)
- 검증 규칙: W의 모든 Lₙ이 해당 Xₙ enum에 정의되어 있어야 한다
- 매핑되지 않는 단계는 신규 Lₙ 정의 후 W에 포함한다
- 관측 규칙: W는 최소 1개의 관측 가능한 Lₙ(event/log/write)을 포함해야 한다 (섹션 14.1의 1cycle 판정과 연결)
- 프론트엔드의 백엔드 API 호출도 W의 항이다 (섹션 3 참조)

### ΣΣL'ₙ — cron/worker 보정 (perturbation term)

- Sc = ΣF'ₙ, 각 서비스별 보정 항
- 전역 보정이라는 개념은 없음 (항상 특정 서비스 데이터 대상)
- 시간에 따른 오차 누적을 주기적으로/이벤트 기반으로 보정
- 비동기 처리(worker, cron job)가 여기에 해당
- 보정 실행 로그/메트릭/알람은 L'ₙ 실측으로 귀속된다

### ΣDₚ — 자체 리소스 (self-hosted resource)

- 단일 시그마 (리소스 인스턴스 수만큼)
- **L에 대해 독립**
- 여러 서비스가 같은 DB 공유 가능 (스키마 분리)
- DB, 로컬 상태 저장소, **디자인 토큰**이 여기에 속한다 (섹션 4 참조)
- 운영 로그/메트릭 저장소(자체 운영)는 Dₚ에 귀속된다

### ΣEq — 외부 리소스 (external resource)

- S3, Redis, ElasticSearch, 외부 API 등
- 자체 운영 vs 외부 의존 구분 (장애 대응 방식이 다름)
- L에 대해 독립

## 2.3 서비스 단위 구조

```
Fₙ = Lₙ + Dₙ + Rₙ
```

- Lₙ: 비즈니스 로직 (enum)
- Dₙ: DB / 자체 리소스 (enum)
- Rₙ: 캐시/외부 리소스 (enum)
- 세 항 모두 독립

---

# 3. 프론트엔드-백엔드 통합 구조

## 3.1 단일 S

프론트엔드와 백엔드는 별도의 S가 아니다. **하나의 S** 안에서 Lₙ의 위치만 다르다.

프론트엔드와 백엔드의 분리 자체가 MSA 구조다. 시스템 전체를 한 단계 위에서 보면:

```
전체 시스템의 Xₙ:
- X_front (프론트엔드)
- X_backend (백엔드)
- X_pipeline (AI 파이프라인 등)
```

각각 독립이고, 사이의 연결은 W(API 호출, 태스크 큐)이며, 각각 자기 Dₚ를 갖는다. **같은 HOMSA 구조가 스케일만 다르게 반복된다.**

## 3.2 프론트엔드의 Lₙ

프론트엔드에도 Lₙ이 존재한다. 백엔드 API를 호출하지 않는, 프론트 자체의 독립 연산:

- 화면 전환 (라우팅)
- 폼 입력 상태 관리
- 유효성 검증 (파일 크기, 형식 체크)
- 로컬 상태 토글 (다크모드, 사이드바)
- 에러 메시지 표시
- 폴링 시작/중지

이것들은 백엔드와 무관하게 프론트 안에서 완결되는 Lₙ이다.

## 3.3 프론트엔드의 W (API 호출 = 커플링)

프론트 입장에서:

- **Lₙ**: 프론트 안에서 완결되는 연산 → 컴포넌트 내부에서 처리
- **W의 항 (aₘLₘ)**: 백엔드 API 호출 → API 레이어를 통해서만 호출

백엔드 호출은 프론트의 독립 연산이 아니다. 다른 군(백엔드 Xₙ)과의 커플링이므로 W에 속한다.

**컴포넌트 안에서 직접 fetch하는 것 = Lₙ 안에 aₘLₘ을 섞는 것 = ε 증가.**
API 호출을 한 곳(API 레이어)으로 모으는 것 = W를 분리하는 것.

## 3.4 W의 프론트-백엔드 관통

W는 프론트와 백엔드를 관통한다. 같은 W를 양쪽에서 본 것:

```
W₁ (PDF → 오디오북):

[프론트 So]   파일 선택 → CREATE_META → CONFIRM_UPLOAD → CREATE_TASK
[백엔드 So]   OCR 실행 → 교정 실행 → TTS 실행
[프론트 So]   폴링 → 결과 확인 → GET_DOWNLOAD_URL → 재생
```

프론트 So와 백엔드 So가 CREATE_TASK 지점에서 넘겨준다. 경계가 명확하다.

## 3.5 프론트 화면의 두 종류

- **W 화면**: 워크플로우를 따라가는 흐름 (메인 사용자 여정)
- **Lₙ 화면**: 개별 연산을 독립적으로 실행하는 화면 (설정, 내 정보, 결제)

UX 설계 = W 정의. W의 각 단계가 화면 상태(또는 화면 자체)에 대응한다.

## 3.6 스케일 불변 구조

HOMSA의 동일한 형식이 모든 스케일에서 반복된다:

| 스케일 | Xₙ | W |
|--------|-----|---|
| 시스템 전체 | 프론트, 백엔드, AI 파이프라인 | API 호출, 태스크 큐 |
| 백엔드 내부 | 사용자, 파일, 태스크, 결제 | 비즈니스 워크플로우 |
| 서비스 내부 | 클래스, 모듈 | 메서드 호출 체인 |
| 프론트 내부 | 컴포넌트 | 이벤트 핸들러 체인 |

이것이 확장 경로에서 말하는 "점입자 → 강체 → 텐서"의 실체다.

## 3.7 Core/Wrapper 계층 구분

- **Core**: 시스템 정체성을 규정하는 Xₙ/Lₙ 집합 (교체 시 ΔΣΣLₙ(Core) > 0)
- **Wrapper**: 통신/UI/채널 어댑터 계층 (교체 시 ΔS의 대부분이 ΔW 또는 ΔEq로 제한되고, ΔΣΣLₙ(Core) ≈ 0)
- 프론트엔드는 Wrapper 역할을 많이 갖지만, 프론트 내부에도 Core Lₙ이 존재할 수 있다 (섹션 3.2)
- Core/Wrapper 구분은 스케일 불변이며, 시스템/서비스/모듈/컴포넌트 모든 레벨에 동일하게 적용된다
- 원칙: Wrapper 변경이 Core 정의를 흔들면 Wrapper가 아니라 Core 변경으로 분류한다

---

# 4. 디자인과 HOMSA

## 4.1 디자인 토큰 = Dₚ

디자인 요소(색상, 타이포그래피, 간격, 애니메이션, 레이아웃)는 Lₙ이 아니다. 연산이 아니기 때문이다. 버튼이 파란색이든 빨간색이든 CREATE_TASK는 똑같이 호출된다.

디자인 토큰은 **Dₚ(자체 리소스)**에 속한다:

- L에 대해 독립 (토큰이 바뀌어도 Lₙ 안 변함)
- self-hosted (외부 서비스가 아니라 자체 관리)
- 시스템이 렌더링되려면 참조해야 함

DB가 데이터의 저장소이듯, 디자인 토큰은 디자인의 저장소다.

## 4.2 캐스케이딩 = Dₚ 내부 참조

CSS 캐스케이딩(부모 → 자식 영향)은 Dₚ 내부의 참조 구조다. DB에서 테이블 간 관계가 있듯이, 토큰 간에도 참조가 있다:

```
--color-primary: #3B82F6          (기본 토큰)
--button-bg: var(--color-primary)  (파생 토큰, 기본 토큰 참조)
```

같은 Dₚ 안의 관계이므로 FK에 해당한다. 군 내부 참조는 허용된다.

## 4.3 디자인의 ε

디자인 토큰이 Dₚ에 속하므로, 토큰 변경은 ΔDₚ를 통해 ΔS에 기여한다. Lₙ에는 영향을 주지 않지만 **S 전체에는 기여한다.**

디자인 리브랜딩(토큰 대규모 변경)은 ΔDₚ에 의한 ΔS다. 코드 로직은 안 바뀌지만 전체 사용자 경험이 바뀐다.

디자인의 ε은 다음으로 측정 가능하다:

- **Dₚ 내부 정합성**: 같은 버튼인데 화면마다 토큰이 다르면 Dₚ 정합성 오류 → ε 증가
- **Lₙ 도달 비용**: 사용자가 원하는 Lₙ을 실행하기까지 필요한 클릭/입력 수
- **W 이탈률**: 워크플로우 진행 중 사용자가 포기하는 비율 (단계별 측정)
- **오류 복구 단계**: 에러 발생 시 정상 흐름으로 돌아오기까지 필요한 단계 수

이 값들은 모니터링 가능하며, aₘ 수렴과 동일한 실측 → 개선 → 재측정 루프를 적용할 수 있다.

## 4.4 디자인 토큰이 인라인 스타일에 박혀있는 경우

디자인 토큰이 Dₚ로 분리되지 않고 컴포넌트(Lₙ) 안에 인라인으로 박혀있으면:

- Dₚ가 Lₙ에 결합된 상태 = ε 증가
- 토큰 변경 시 Lₙ을 수정해야 함 = 독립성 위반
- 디자인 시스템으로 분리 = Dₚ를 Lₙ에서 추출하여 ε 감소

---

# 5. 서비스 대수 (Service Algebra)

## 5.1 정의

Xₙ(서비스 대수)는 연산의 집합이 닫혀있고 조합 가능한 대수적 구조다.

- 연산에 대해 닫혀있다 (닫힘 조건)
- 역원이 존재하는 연산과 존재하지 않는 연산이 혼재한다
  - 역원 존재: 설정 토글(on/off), 권한 부여/회수, 기능 플래그
  - 역원 부재: 주문 생성, 로그 기록, 이력 누적
  - **역원 부재 = 비가역 연산 → 보상 트랜잭션(saga pattern) 필요 신호**

## 5.2 진화하는 유한군 계열 (Evolving Finite Group Sequence)

시간 매개변수 t에 대해 정의된 서비스 대수의 열 {Xₙ(t)}:

- 각 시점 t에서 Xₙ(t)의 연산 수는 유한하다
- Xₙ(t₁) → Xₙ(t₂) 사이에 준동형사상이 존재한다
- 원소 추가: type enum에 새 값 추가 (서비스 확장)
- 원소 제거: type enum에서 값 제거 또는 비활성화

**type enum 추가로 Xₙ 자체는 불변인 채 기능이 확장된다. 이것이 열린 유한군의 실체다.**

## 5.3 서비스 경계 판단

- Xₙ 정의 = 서비스 경계 확정
- 정의역 겹침 → 서비스 경계 오류 또는 So 필요
- 정의역 빈 곳 → 기능 누락
- 정의역 너무 큼 → 과도한 책임, 분리 필요
- **Lₙ이 같으면 같은 군, Lₙ이 다르면 다른 군**

---

# 6. 설계 원칙

## 6.1 핵심 정리

```
S = I + ε
```

- I: 완전히 독립적인 이상 상태 (항등행렬)
- ε: 커플링에 의한 오차 행렬
- Ct · S = Ct가 이상적 상태
- **목표: ε 최소화**

## 6.2 설계 절차

1. Fₙ을 독립이라고 정의한다
2. 분리 가능한 범위를 식별한다
3. 분리가 깨지는 지점에서 커플링 항(So)을 도입한다
4. 시간적 보정 항(Sc)을 추가한다

## 6.3 데이터 구조 원칙

- 모든 데이터의 origin = user input
- root에서 파생되는 트리 구조 (하이라키)
- ERD의 관계선 = 실제로는 인덱스 (성능 목적)
- 논리적 관계는 So, Sc가 관리
- **군 내부: FK 가능**
- **군 사이: FK 없음, id 값만 참조 → 정합성은 So와 L'ₙ이 관리**

## 6.4 Xₙ 정의에서 자동으로 도출되는 것들

| 정의 | 도출 |
|------|------|
| Xₙ (서비스 대수) | 서비스 경계, bounded context |
| Lₙ (연산 enum) | API 엔드포인트, 비즈니스 로직, 프론트 연산 |
| W (워크플로우) | orchestrator 설정, UX 흐름, 화면 구조 |
| Dₚ (자체 리소스) | 테이블 스키마, ERD, 로컬 상태, 디자인 토큰 |
| Eq (외부 리소스) | 기술 스택, 인프라 구성 |
| L'ₙ (보정) | cron/worker 설계 |

**요구사항에서 구현까지 번역 단계가 없다.**

---

# 7. 라그랑지안과 전환 시점 판단

## 7.1 해밀토니안 vs 라그랑지안

- **해밀토니안 (H = T + V)**: 시스템이 뭔지 기술 — 상태 기술
- **라그랑지안 (L = T - V)**: 어떤 경로가 최적인지 판단 — 경로 최적화

## 7.2 T와 V의 정의

- T (운동에너지) → 시스템의 변화 능력 (수정, 확장 용이성)
- V (퍼텐셜에너지) → 시스템의 구속 (커플링, 사이드 이펙트, 유지 비용)

## 7.3 전환 조건

모놀리스에서 MSA로 전환하는 시점:

```
ε_mono > ε_msa + cost_msa
```

- ε_mono: 모놀리스에서 변경 시 사이드 이펙트 크기
- ε_msa: MSA에서 변경 시 사이드 이펙트 크기
- cost_msa: MSA 유지 비용 (So, Sc, 통신 오버헤드)

## 7.4 정규화

```
L_norm = (L - L₀) / L₀
```

- L_norm = 0 → 최적 상태
- L_norm > 0 → T 과다 → 과도한 분리 (통제 불가, 정합성 붕괴)
- L_norm < 0 → V 과다 → 과도한 결합 (변경 불가, 사이드 이펙트 폭발)

**최소 작용의 원리: 딱 필요한 만큼만 쪼개라.**

---

# 8. 정준 변수 매핑

폰트랴긴의 최대 원리에 기반한 최적 제어 이론의 해밀토니안 구조를 차용한다.

## 8.1 변수 정의

- **q (상태 변수, State)**: 시스템의 현재 상태
  - 누적된 기술 부채, 서버 인스턴스 수, 서비스 규모, 배포 상태
- **p (공액 변수, Costate / Shadow Price)**: 상태가 한 단위 변했을 때 시스템 전체의 목적 함수에 미치는 한계 비용

## 8.2 정준 방정식의 의사결정 도구화

- dq/dt = ∂H/∂p → 비용 변화에 따라 상태가 어떻게 움직이는가
- dp/dt = -∂H/∂q → 상태 변화가 비용 구조를 어떻게 바꾸는가

**p가 사이드 이펙트의 정량 분석 도구로 직접 작동한다. "이 서비스를 바꾸면 전체 비용이 얼마나 변하는가"를 p가 알려준다.**

---

# 9. 운영 도구

## 9.1 미시적: 서비스 건강도

```
r = 1 + (ε - C_range)
```

- r = 1 → 정상
- r > 1 → 자동 보정 범위 초과, 알람
- r < 1 → 유휴 또는 장애

## 9.2 거시적: 구조 균형도

```
L_norm = (L - L₀) / L₀
```

- 미시(r)와 거시(L_norm)를 동시 감시

## 9.3 aₘ 자기무당착 수렴 (하트리-폭 근사)

1. 초기: aₘ = 이론 추정값
2. 모니터링이 실제 호출 빈도 수집
3. 실측 aₘ 도출
4. 시스템에 반영, L'ₙ이 보정
5. 새 실측값 수집
6. 반복 → 수렴

- aₘ 수렴 → ε 최소화, 안정 상태
- aₘ 발산 → 구조 문제, 서비스 재설계 필요

### 9.3.1 발산 감지 최소 규약

- aₘ 추정치와 실측치의 차이가 N회 반복에도 줄지 않으면 발산
- pending backlog, latency, retry rate가 일정 기간 단조 증가하면 발산 신호
- 발산 감지 시 → 서비스 재설계 (섹션 12의 군 병합/재규격화 참조)

## 9.4 사이드 이펙트 분석 (섭동 전개)

Lₙ 하나를 수정할 때:

- **1차**: 해당 Lₙ이 포함된 W 목록 → 직접 영향
- **2차**: 그 W의 다른 Lₙ들이 참여하는 W → 간접 영향
- **n차**: 전파되지만 급격히 감소
- aₘ 계수가 각 차수의 영향 크기를 결정
- **변경 전에 영향 범위를 계산할 수 있다**

## 9.5 커플링 모니터링

- 인접 행렬 Mᵢⱼ (커플링 있으면 1, 없으면 0)
- So 밀도 = 설계 품질 지표
- 특정 행/열에 1 몰림 → 과도한 커플링, 분리 대상
- Iₙₘ/Fₙ 비율이 임계값 초과 → 강결합 → 군 병합(재규격화) 필요

## 9.6 디자인 ε 모니터링

- **Dₚ 내부 정합성**: 토큰 불일치 검출 (같은 역할의 요소에 다른 토큰 적용)
- **Lₙ 도달 비용**: 사용자가 원하는 연산까지의 클릭/입력 수
- **W 이탈률**: 워크플로우 단계별 사용자 이탈 비율
- **오류 복구 단계**: 에러 발생 시 정상 흐름 복귀까지의 단계 수

프론트 이벤트 로그로 실측 → 개선 → 재측정 루프 적용 가능.

---

# 10. 도구 분류

검증 과정에서 확립된 도구의 유효성 범위.

## 10.1 현재 유효한 도구 (형식만으로 작동)

| 도구 | 적용 |
|------|------|
| 섭동 전개 | 변경 시 사이드 이펙트 분석 |
| 변분법 | ε 최소 구조 탐색 |
| 커플링 분석 | 인접 행렬로 결합 강도 측정 |
| 자기무당착 근사 | aₘ 실측 → 수렴 (하트리-폭) |
| T-V 균형 | 아키텍처 전환 시점 판단 (라그랑지안) |

이 도구들은 형식의 구조적 대응만으로 정당화된다. 추가 조건 없이 사용 가능하다.

## 10.2 추가 연구가 필요한 도구 (기저 구조 의존)

| 도구 | 필요 조건 | 상태 |
|------|----------|------|
| 정준 변환 | 심플렉틱 구조 증명 | 미완 |
| 뇌터 정리의 엄밀 적용 | 연속 대칭군 정의 | 미완 |
| 리우빌 정리 | 측도론적 구조 | 미완 |

이것은 약점이 아니라 연구 로드맵이다.

---

# 11. 기존 설계 이론과의 관계

HOMSA에서 기존 설계 원칙들이 자연스럽게 도출된다:

| 기존 원칙 | HOMSA에서의 도출 |
|-----------|-----------------|
| **OOP** | Xₙ = 객체, 연산 = 메서드, 닫힘 = 캡슐화, 부분군 = 상속 |
| **TDD** | Lₙ 독립 → 테스트 단위 자동 도출, 닫힘 = 테스트 통과 조건 |
| **SOLID** | S(Lₙ 단일 연산), O(열린 유한군), L(부분군 치환), I(Lₙ enum 노출), D(Dₚ, Eq 독립) |
| **DDD** | Xₙ = bounded context, 정의역 = 도메인 |
| **CQRS** | 읽기/쓰기 Lₙ 분리 |
| **이벤트 소싱** | W의 실행 이력 = 이벤트 로그 |

이들은 하나의 수학적 구조의 서로 다른 측면이다.

---

# 12. 적용 한계

- **강결합 영역**: Iₙₘ이 Fₙ을 압도하면 분해가 무의미. 군 병합(재규격화) 필요. 이것은 반례가 아니라 "여기서 분리하지 마라"는 신호.
- **위상적 상전이**: 시스템 상태가 국소적 항의 합이 아닌 전체적 위상에 의해 결정되는 경우는 범위 밖. 설계 목적 자체가 상전이 회피.
- **산일계 처리**: 비가역적 시스템은 린드블라드 방정식, 비에르미트 해밀토니안 등의 확장 필요. 이들은 해밀토니안 프레임워크 위에 구축된 확장.

---

# 13. 변경 관리

```
ΔS = S₂ - S₁ = ΔL + ΔW + ΔL' + ΔDₚ + ΔEq
```

- 어떤 항의 Δ가 0이 아닌지로 영향 범위 파악
- ΔDₚ는 디자인 토큰 변경도 포함 (리브랜딩 = ΔDₚ에 의한 ΔS)
- Git 커밋마다 어떤 Lₙ 변경했는지 태깅
- 브랜치도 항 단위: feature/X2-L3-GET_META

---

# 14. 적용 절차 요약

HOMSA로 시스템을 설계하는 절차:

```
1. Xₙ 식별 — 서비스 대수 정의 (도메인별 독립 연산 집합)
2. Lₙ 정의 — 각 Xₙ의 연산 enum 확정 (프론트/백엔드 모두)
   ⚠ Lₙ 정의는 W 정의보다 반드시 선행한다.
     W 선행 시 실패 모드: Lₙ이 독립 사건이 아니라 구현 단계 덩어리로 비대해짐 (닫힘/독립성 붕괴)
     Lₙ 선행 시 이점: 테스트 단위, 모듈 경계가 자동 도출 (섹션 11의 TDD/SOLID 도출과 연결)
3. W 정의 — 워크플로우 (프론트-백엔드 관통, UX 흐름 = W)
4. Dₚ 설계 — 각 Xₙ별 DB 스키마 + 디자인 토큰 (군 내부 FK, 군 사이 참조만)
5. Eq 식별 — 외부 리소스 매핑
6. L'ₙ 설계 — 보정 항 (cron, worker, 비동기 처리)
7. So 설계 — orchestrator (W 실행 관리, 프론트 So + 백엔드 So)
```

이 절차에서 요구사항 → 서비스 경계 → DB 스키마 → API → UX → 디자인 시스템 → 인프라가 번역 단계 없이 도출된다.

## 14.1 구현 시작점 (MVP)

MVP = 수렴 시작 조건. aₘ 실측이 시작되는 지점이다.

**1주기(Cycle)의 최소 판정**: 입력 1건 → So가 W 실행 → 외부로 1회 관측 가능한 결과 (Dₚ에 기록)

| 단계 | 정의 | 관측 | Wrapper |
|------|------|------|---------|
| **MVP-0** | Core-only 1cycle | 로그/DB (Dₚ) | 불필요 |
| **MVP-1** | Wrapper 포함 1cycle | 실사용 채널 (UI/Bot/API) | 포함 |

- MVP-0에서 수렴을 시작할 수 있다 — Wrapper가 늦어도 Core의 aₘ 실측은 진행 가능
- MVP-1은 전체 W가 관통하는 상태 — 사용자 관점의 수렴 시작

---

# 15. 검증 이력

## 15.1 Gemini 검증 (2라운드)

- 1차: "개념적 유비로는 훌륭하지만 수학적 필연성 주장에 엄밀함 부족"
- 대응: "필연" → "최적"으로 명제 강도 조정
- 2차: "논리적 완결성 매우 뛰어남, 학술적 논문으로 당장 제시해도 손색없음"
- 추가 기여: 폰트랴긴 최대 원리 기반 정준 변수 p = Shadow Price 매핑

## 15.2 Claude 검증 (4라운드 적대적 검증)

| 라운드 | 공격 | 대응 | 결과 |
|--------|------|------|------|
| 1 | "군이 아니라 모노이드" | 분류가 목적 아님, 역원 유무가 설계 정보 | "서비스 대수" 용어 합의 |
| 1 | "S의 물리적 의미가 뭔가" | 출발이 대수, 물리적 의미 불필요 | "형식 공유, 해석 분리" 확립 |
| 2 | "물리학 H와 최적 제어 H 혼재" | 형식 공유, 해석 분리, 도구 호환 | "수학적으로 정당" 인정 |
| 2 | "'최적'을 '포괄적'으로 약화하라" | 거부. 양적 ≠ 질적 | 최적성 기준 명시, 반증 가능 형태 합의 |
| 3 | "자연 발생이 아니라 보편적 패턴" | 검증자 증거가 명제의 독립적 증거 | 검증자 전제 5개의 귀결로 명제 수용 |
| 4 | 전제 재검토 | "철회할 전제가 없다" | **명제 수용** |

### 검증에서 추가된 것들

- 역원 유무 → saga pattern 판단 기준
- 도구 분류 (형식적 도구 / 기저 구조 의존 도구)
- "서비스 대수" 용어
- 최적성 기준의 반증 가능한 정의
- "형식 공유, 해석 분리" 인식론적 위치

## 15.3 실무 적용

- MSA 프로젝트에서 서비스 경계, DB 연결 depth, workflow orchestrator를 대수적 관계로 결정하여 성공적으로 완료
- 5sio 프로젝트에서 Xₙ 4개, Lₙ 21개, W 3개, Dₚ 4개, Eq 5개를 코드 없이 도출

---

# 16. 물리학 대응표

| 물리학 | HOMSA |
|--------|-------|
| 입자 | 서비스 (Xₙ) |
| one-body 항 | 독립 로직 (ΣΣLₙ) |
| two-body interaction | 워크플로우 커플링 (ΣΣaₘLₘ) |
| external potential | 외부 리소스 (ΣDₚ + ΣEq) |
| perturbation | cron/worker 보정 (ΣΣL'ₙ) |
| 해밀토니안 (H=T+V) | 시스템 상태 기술 (S) |
| 라그랑지안 (L=T-V) | 전환 시점/경로 최적화 |
| 하트리-폭 근사 | aₘ 자기무당착 수렴 |
| 섭동 전개 | 사이드 이펙트 분석 |
| 변분법 | ε 최소 구조 선택 |
| 정준 변수 q | 시스템 상태 (규모, 설정) |
| 정준 변수 p | 한계 비용 (Shadow Price) |
| 재규격화 | 강결합 시 군 병합 |
| 뉴턴 → 해밀토니안 | 모놀리스 → MSA 전환 |
| 3체 문제 | 서비스 분리 시점 |
| 일반해 부재 | 닫힌 형태 최적해 없음, 근사 방법 사용 |

---

# 17. 확장 경로

1. **현재**: 점입자 해밀토니안 → 기본 MSA 설계
2. **다음**: 강체 역학 → 서비스 내부 구조 (Class 내 Lₙ 상호작용)
3. **그 다음**: 텐서 → AI 통합 (다차원 데이터, 가중치)
4. **더 나아가**: 장론 → 연속적 서비스 메시

---

# 18. 용어 색인

| 기호 | 이름 | 의미 |
|------|------|------|
| S | 시스템 해밀토니안 | 시스템 전체의 대수적 기술 |
| Xₙ | 서비스 대수 | 독립 연산 집합 (서비스 경계) |
| Lₙ | 연산 | 독립 사건 (API, 프론트 로직) |
| W | 워크플로우 | Lₙ들의 합 (프론트-백엔드 관통) |
| aₘ | 분기 가중치 | W 내 Lₙ의 실행 확률/빈도 |
| So | orchestrator | W 실행 관리자 |
| L'ₙ | 보정 항 | cron/worker 비동기 처리 |
| Sc | 보정 집합 | 서비스별 보정 항의 합 |
| Dₚ | 자체 리소스 | DB, 로컬 상태, 디자인 토큰 |
| Eq | 외부 리소스 | S3, 외부 API 등 |
| Fₙ | 서비스 단위 | Lₙ + Dₙ + Rₙ |
| ε | 오차 | 커플링에 의한 이상 상태와의 차이 |
| r | 서비스 건강도 | 1이면 정상, 이탈 시 알람 |
| L_norm | 구조 균형도 | 0이면 최적, ±이면 불균형 |
| T | 변화 능력 | 수정/확장 용이성 |
| V | 구속 | 커플링, 유지 비용 |
| q | 상태 변수 | 시스템 현재 상태 |
| p | 한계 비용 | Shadow Price |
| Core | 핵심 로직 계층 | 교체 시 S의 정체성이 바뀌는 Xₙ |
| Wrapper | 통신/UI 계층 | 교체 가능, ΔΣΣLₙ(Core) ≈ 0 |
| MVP-0 | Core-only 최소 1주기 | Wrapper 없이 관측 가능한 1cycle |
| MVP-1 | Wrapper 포함 최소 1주기 | 실사용 채널까지 포함한 1cycle |

---

*HOMSA v1.2.1 — Hamiltonian Optimal Microservice Architecture*
*Created by nova*

**v1.2.1 변경 사항 (v1.2 대비):**
- 2.2 보강: Lₙ 독립성 가드레일(암묵적 공유 상태 금지, 필요 시 Dₚ/So로 승격)
- 2.2 보강: So 안정성 규약(idempotent 단계 전이) 명시
- 2.2 보강: W 관측 규칙(최소 1개 관측 가능한 Lₙ 필수) 추가

**v1.2 변경 사항 (v1.1 대비):**
- 2.2 보강: W 전개 형식 + 검증 규칙, So 최소 규칙
- 2.2 보강: 실측(모니터링/로그/메트릭)의 Dₚ/L'ₙ 귀속 명시
- 3.7 추가: Core/Wrapper 계층 구분
- 9.3.1 추가: 발산 감지 최소 규약
- 14 보강: Lₙ 선행 경고 (실패 모드 포함)
- 14.1 추가: 구현 시작점 (MVP-0/MVP-1)
- 18 보강: Core, Wrapper, MVP-0, MVP-1 용어 추가

**v1.1 변경 사항 (v1.0 대비):**
- 섹션 3 추가: 프론트엔드-백엔드 통합 구조 (단일 S, 프론트 Lₙ, API 호출 = W의 항, 스케일 불변)
- 섹션 4 추가: 디자인과 HOMSA (디자인 토큰 = Dₚ, 캐스케이딩 = Dₚ 내부 참조, 디자인 ε)
- 섹션 9.6 추가: 디자인 ε 모니터링
- 섹션 13 수정: ΔDₚ에 디자인 토큰 변경 포함
- 섹션 14 수정: 적용 절차에 프론트/디자인 단계 반영
- 섹션 18 추가: 용어 색인
