import type { Eq1Client } from "../eq1/llm-client";
import { createLogger } from "../utils/logging";
import type { Interaction, Store, Task, TaskType } from "../x2/store";
import type { InteractionEvaluation } from "../x3/evaluator";
import { summarizeInteractionContext } from "./summarizer";

const logger = createLogger("X4.Router");

export interface X4RouteDecision {
    action: "report" | "new_task" | "skip";
    reason: string;
    prompt: string | null;
    raw: Record<string, unknown>;
}

function isRecord(value: unknown): value is Record<string, unknown> {
    return typeof value === "object" && value !== null && !Array.isArray(value);
}

function toText(value: unknown): string | null {
    return typeof value === "string" && value.trim().length > 0 ? value : null;
}

function normalizeAction(value: unknown): X4RouteDecision["action"] | null {
    const text = toText(value)?.toLowerCase();
    if (!text) return null;
    if (text === "new_task" || text === "task" || text === "enqueue") {
        return "new_task";
    }
    if (text === "report" || text === "notify" || text === "user") {
        return "report";
    }
    if (text === "skip" || text === "none" || text === "noop") {
        return "skip";
    }
    return null;
}

function fallbackAction(evaluation: InteractionEvaluation): X4RouteDecision["action"] {
    return evaluation.score > 6 ? "report" : "skip";
}

function buildTaskPrompt(
    action: X4RouteDecision["action"],
    summaryText: string,
    output: Record<string, unknown>,
    fallbackReason: string,
): string {
    const direct =
        toText(output.prompt) ??
        toText(output.task_prompt) ??
        toText(output.instruction) ??
        toText(output.message);
    if (direct) return direct;

    if (action === "new_task") {
        return `Follow-up task generated by X4: ${fallbackReason}`;
    }
    if (action === "report") {
        return `X4 report:\n${summaryText}`;
    }
    return fallbackReason;
}

export class X4Router {
    private store: Store;
    private eq1Client: Eq1Client;

    constructor(store: Store, eq1Client: Eq1Client) {
        this.store = store;
        this.eq1Client = eq1Client;
    }

    async routeInteraction(
        interaction: Interaction,
        evaluation: InteractionEvaluation,
    ): Promise<{ decision: X4RouteDecision; task: Task | null }> {
        const summary = summarizeInteractionContext(interaction, evaluation);
        const summaryText = JSON.stringify(summary, null, 2);

        let output: Record<string, unknown> = {};
        try {
            const result = await this.eq1Client.route(summaryText, {
                interactionType: interaction.type,
                requestId: interaction.requestId,
                source: "x4_router",
            });
            output = isRecord(result.output) ? result.output : {};
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            logger.warn("x4_route_call_failed", {
                interaction: interaction.id.slice(0, 8),
                requestId: interaction.requestId,
                error: message,
            });
        }

        const action = normalizeAction(output.action) ?? fallbackAction(evaluation);
        const reason =
            toText(output.reason) ??
            toText(output.route_reason) ??
            evaluation.reason;
        const prompt =
            action === "skip"
                ? null
                : buildTaskPrompt(action, summaryText, output, reason);

        let task: Task | null = null;
        if (action !== "skip" && prompt) {
            const type: TaskType = action === "new_task" ? "omo_request" : "report";
            task = this.store.createTask(prompt, "x4", type);
        }

        logger.info("x4_route_decision", {
            interaction: interaction.id.slice(0, 8),
            requestId: interaction.requestId,
            action,
            task: task ? task.id.slice(0, 8) : null,
        });

        return {
            decision: {
                action,
                reason,
                prompt,
                raw: output,
            },
            task,
        };
    }
}
